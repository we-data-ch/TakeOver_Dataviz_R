<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Exercice 1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Ggplot2_files/libs/clipboard/clipboard.min.js"></script>
<script src="Ggplot2_files/libs/quarto-html/quarto.js"></script>
<script src="Ggplot2_files/libs/quarto-html/popper.min.js"></script>
<script src="Ggplot2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Ggplot2_files/libs/quarto-html/anchor.min.js"></script>
<link href="Ggplot2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Ggplot2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Ggplot2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Ggplot2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Ggplot2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Exercice 1</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Tous les tracés sont composés de <strong>données</strong> que vous souhaitez visualiser et d’un ensemble d’éléments esthétiques :</p>
<ul>
<li><p><strong>des données</strong> que vous souhaitez visualiser et d’un ensemble de <strong>mappings</strong> esthétiques décrivant la façon dont les variables des données sont mises en correspondance avec les données. <strong>esthétiques</strong> décrivant comment les variables des données sont mises en correspondance avec Les attributs esthétiques que vous pouvez percevoir.</p></li>
<li><p>Des <strong>couches</strong> composées d’éléments géométriques et de transformations statistiques. statistiques. Les objets géométriques, <strong>géomes</strong> en abrégé, représentent ce que vous voyez réellement sur le graphique : points, lignes, polygones, etc. Les transformations statistiques, ou stats en abrégé, résument les données de nombreuses de nombreuses façons utiles. Par exemple, le regroupement et le comptage des observations pour pour créer un histogramme, ou résumer une relation à 2d avec un modèle linéaire.</p></li>
<li><p>Les <strong>échelles</strong> transforment les valeurs de l’espace de données en valeurs dans un espace esthétique, qu’il s’agisse de la couleur, de l’eau ou de l’air. espace esthétique, qu’il s’agisse de la couleur, de la taille ou de la forme. Les échelles dessinent une légende ou des axes, qui fournissent une cartographie inverse permettant de de lire les valeurs des données originales sur le graphique.</p></li>
<li><p>Un système de coordonnées, <strong>coord</strong> en abrégé, décrit la façon dont les coordonnées des données dans le plan du graphique. Il fournit également axes et des lignes de quadrillage pour permettre la lecture du graphique. Nous Nous utilisons normalement un système de coordonnées cartésiennes, mais il en existe d’autres, notamment les coordonnées polaires et les cartes. sont disponibles, y compris les coordonnées polaires et les projections cartographiques.</p></li>
<li><p>Une <strong>facet</strong>ing speciﬁcation décrit comment décomposer les données en sous-ensembles et comment afficher ces sous-ensembles en fonction de la taille de l’échantillon. sous-ensembles et comment afficher ces sous-ensembles sous forme de petits multiples. C’est ce qu’on appelle également connu sous le nom de conditionnement ou de latticage/treillis.</p></li>
<li><p>Un <strong>thème</strong> qui contrôle les points essentiels de l’affichage, comme la taille de la police et la couleur de fond. la taille de la police et la couleur de fond. Bien que les valeurs par défaut de ggplot2 aient été ont été choisies avec soin, il se peut que vous deviez consulter d’autres références pour créer un graphique attrayant. pour créer un graphique attrayant.</p></li>
</ul>
<section id="exercise-1" class="level3">
<h3 class="anchored" data-anchor-id="exercise-1">Exercise 1</h3>
<p>“Pour les exercices suivants, nous utiliserons l’ensemble de données <code>starwars</code> du package <code>dplyr</code>. Le graphique de base sur lequel nous travaillerons est celui des variables <code>name</code>, <code>mass</code>, <code>height</code> et <code>hair_color</code>. Tracez-le en utilisant la fonction <code>geom_point()</code>.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/Base%20plot-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Comment pouvons-nous améliorer sa lisibilité ?”</p>
<p>Nous pourrions même marquer de manière distincte les <code>NA</code>s ! Il suffit de définir la couleur des <code>NA</code>s avec l’argument dans la fonction <code>scale*</code> appropriée. Dans notre cas, <code>scale_fill_discrete(na.value = "nom_de_la_couleur")</code>.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/Base%20plot%20with%20different%20colour%20for%20NAs-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Nous pouvons utiliser d’autres fonctions dans nos graphiques, chacune avec ses esthétiques correspondantes pour contrôler la manière dont les données sont représentées. Les principales sont :</p>
<ul>
<li><p>pour les graphiques de dispersion : <code>geom_point()</code> ;</p></li>
<li><p>pour les graphiques en courbes :</p>
<ul>
<li><p><code>geom_line()</code> : relie les points de données en produisant des lignes de gauche à droite.</p></li>
<li><p><code>geom_path</code> : relie les points de données dans l’ordre où ils apparaissent, résultant en un trajet non linéaire.</p></li>
</ul></li>
<li><p>pour les graphiques à barres et les histogrammes : <code>geom_bar()</code> ;</p></li>
<li><p>pour les histogrammes : <code>geom_histogram()</code> ;</p></li>
<li><p>pour les boîtes à moustaches : <code>geom_boxplot()</code> ; pour les cartes thermiques : <code>geom_tile()</code> ;</p></li>
<li><p>pour les polygones et les formes remplies : <code>gom_polygon()</code>.</p></li>
<li><p>Enfin, nous pouvons ajouter des étiquettes de texte à un graphique avec la fonction <code>geom_text()</code>. Voici ses principales esthétiques : <code>label</code>, <code>color</code>, <code>size</code>, <code>angle</code>, <code>hjust</code>, <code>vjust</code>. De plus, pour éviter les chevauchements, nous pouvons utiliser l’argument <code>gom_text(check_overlap = TRUE, , vjust = "inward", hjust = "inward")</code> à l’intérieur de la fonction <code>geom_text()</code>.</p></li>
</ul>
</section>
<section id="exercise-2" class="level3">
<h3 class="anchored" data-anchor-id="exercise-2">Exercise 2</h3>
<p>Au lieu de représenter les observations avec des points, représentez-les avec le nom du personnage auquel elles se réfèrent. Utilisez la fonction <code>geom_text</code> avec les arguments suivants <code>check_overlap = TRUE, vjust = "inward", hjust = "inward"</code> au lieu de <code>geom_point</code>.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>La plupart de ces fonctions partagent les mêmes esthétiques. Les modifier peut améliorer la lisibilité du graphique. Les plus importantes sont :</p>
<ul>
<li><p><code>color</code> : utilisé pour attribuer des couleurs aux points de données, aux lignes ou à d’autres éléments du graphique en fonction d’une variable ;</p></li>
<li><p><code>fill</code> : utilisé pour spécifier la couleur de remplissage des formes, telles que les barres, les zones ou les polygones ;</p></li>
<li><p><code>size</code> : utilisé pour ajuster la taille des éléments de votre graphique, tels que les points ou les lignes. Il n’est pas recommandé d’utiliser la taille pour une variable discrète ;</p></li>
<li><p><code>alpha</code> : utilisé pour contrôler la transparence ou l’opacité des éléments du graphique. Des valeurs plus élevées rendent les éléments plus opaques, tandis que des valeurs plus basses les rendent plus transparents ;</p></li>
<li><p><code>shape</code> : utilisé pour attribuer différentes formes de point aux points de données. Veuillez noter que ggplot2 n’utilisera que six formes à la fois ;</p></li>
<li><p><code>stroke</code> : pour définir la couleur de la bordure ou du contour des formes ;</p></li>
<li><p><code>linetype</code> : utilisé pour contrôler le type de ligne dans les graphiques en ligne, tels que des lignes continues, des lignes en pointillés ou des lignes en pointillés ;</p></li>
<li><p><code>group</code> : utilisé pour regrouper les points de données pour certaines géométries, comme <code>geom_line()</code>, qui connecte les points dans le même groupe ;</p></li>
<li><p><code>label</code> : utilisé pour spécifier les étiquettes de texte associées aux points de données. Généralement utilisé avec <code>geom_text()</code> ou <code>geom_label()</code> pour afficher des étiquettes pour les points de données ;</p></li>
<li><p><code>hjust</code> et <code>vjust</code> : utilisés respectivement pour le justifié horizontal et vertical des étiquettes de texte par rapport à la position spécifiée ; pour ajouter des points étiquetés à un graphique avec un arrière-plan coloré : <code>geom_label()</code> ;</p></li>
<li><p>pour ajouter un lissage aux données et afficher le lissage ainsi que son erreur standard : <code>geom_smooth</code>.</p></li>
</ul>
</section>
<section id="design-du-graphique" class="level1">
<h1>Design du graphique</h1>
<section id="titre-legende-geom-and-axes" class="level2">
<h2 class="anchored" data-anchor-id="titre-legende-geom-and-axes">Titre, legende, geom and axes</h2>
<section id="exercise-3" class="level3">
<h3 class="anchored" data-anchor-id="exercise-3">Exercise 3</h3>
<p>En travaillant sur le graphique de l’exercice 1, ajoutez-lui un titre de votre choix, un titre pour les axes des x et y, ainsi qu’un titre pour la légende. Vous pouvez le faire avec la fonction <code>labs()</code> et les arguments suivants : <code>title = "votre_titre"</code> pour le titre ; <code>x = "nom_de_l'axe_x"</code> ; <code>y = "nom_de_l'axe_y"</code> ; <code>color = "titre de la légende"</code> pour le titre de votre légende.</p>
<p>Si le titre de votre graphique est trop long, envisagez de le diviser en deux lignes avec l’argument entre les deux parties du titre, comme suit : <code>title = "Relation entre les masses des personnages \n et les hauteurs des personnages"</code>.`</p>
<p>De plus, envisagez d’éliminer les valeurs étranges contenues dans la variable <code>hair_color</code> à l’aide du code suivant : <code>filter(hair_color %in% c("auburn", "auburn, grey", "auburn, white", "black", "blond", "blonde", "brown", "brown, grey", "grey", "white"))</code>.</p>
<p>Enfin, placez la légende à gauche et modifiez les noms affichés des valeurs dans la légende. Vous pouvez utiliser les fonctions et arguments suivants: <code>theme.position = "left")</code> ; <code>scale_color_discrete(labels = c("auburn" = "Auburn","auburn, grey" = "Auburn / Grey","auburn, white" = "Auburn / White","black" = "Black","blond" = "Blond","blonde" = "Blonde","brown" = "Brown","brown, grey" = "Brown / Grey","grey" = "Grey","white" = "White"))</code>.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/Adding%20axes%20labels%20and%20a%20title%20in%20two%20lines,%20changing%20legend-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Qu’est-ce qui peut être amélioré sur ce graphique ?</p>
</section>
<section id="exercise-4" class="level3">
<h3 class="anchored" data-anchor-id="exercise-4">Exercise 4</h3>
<p>Créez un nouveau graphique avec la variable <code>mass</code> sur l’axe des x et <code>height</code> sur l’axe des y. Filtrez le poids des observations entre 0 kg et 350, et la hauteur entre 0 et 250 cm. La fonction <code>filter()</code> est votre alliée ici. De plus, ajoutez une ligne de tendance avec son intervalle de confiance et changez la couleur des points de données en bordeaux (#800020). Notez que vous pouvez changer la couleur avec l’argument suivant : <code>color = "nom_de_la_couleur_ou_code_hexadécimal</code> dans la fonction <code>geom_point()</code>.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/With%20the%20CI%20and%20changing%20colour%20of%20dots-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
</section>
<section id="breaks-and-labels" class="level2">
<h2 class="anchored" data-anchor-id="breaks-and-labels">Breaks and Labels</h2>
<p>The <code>breaks</code> argument of <code>scale_x_continuous()</code> <code>scale_y_continuous()</code> controls which values appear as tick marks on the plot’s axes.</p>
<section id="excercise-5" class="level3">
<h3 class="anchored" data-anchor-id="excercise-5">Excercise 5</h3>
<p>À partir du graphique de l’exercice 3, modifiez les valeurs qui apparaîtront sur les axes et dans les légendes. Par exemple, pour l’axe des y, vous pouvez afficher uniquement les valeurs de 100 cm, 150 cm et 200 cm avec le code suivant : <code>scale_y_continuous(breaks = c(100, 150, 200), labels = c("100 cm", "150 cm", "200 cm"))</code>.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
</section>
</section>
<section id="faceting" class="level1">
<h1>Faceting</h1>
<p>La technique de la facette sert de méthode alternative pour incorporer des variables catégoriques supplémentaires dans un graphique. Cette technique segmente les données en divers sous-ensembles, générant et affichant ensuite un graphique identique pour chacun de ces sous-ensembles, créant ainsi une matrice de graphiques. Cela est particulièrement utile pour les variables catégoriques.</p>
<p>Il existe deux fonctions principales pour la facette. La première est <code>facet_wrap()</code>, qui est généralement utilisée pour facetter un graphique par une seule variable catégorique. À l’intérieur de cette fonction, on trouve l’argument <code>nrow</code> pour contrôler le nombre de lignes et l’argument <code>ncol</code> pour contrôler le nombre de colonnes de la facette. La deuxième est <code>facet_grid()</code>, principalement utilisée pour facetter un graphique par deux valeurs catégoriques. Dans cette dernière fonction, le nombre de colonnes est donné par le nombre de niveaux des variables par lesquelles nous facettisons.</p>
<p>Il est également possible de facetter par une seule variable catégorique avec <code>facet_grid()</code>, mais dans ce cas, nous devons écrire un <code>·</code> pour indiquer qu’aucune facette ne doit être effectuée le long de cet axe. Par exemple, si nous ne voulons pas facetter l’axe <code>x</code>, nous écrirons ce qui suit : <code>facet_grid(· ~ )</code>.</p>
<section id="exercise-6" class="level3">
<h3 class="anchored" data-anchor-id="exercise-6">Exercise 6</h3>
<p>Pour cet exercice, prenez le graphique de l’exercice 3, mais ajoutez la variable <code>gender</code> et n’utilisez pas l’argument <code>color</code> dans la fonction <code>aes()</code>, et ne recourez pas aux fonctions <code>theme()</code> et <code>scale_color_discrete()</code>. Sur ce nouveau graphique, vous devez le facetter par la variable hair_color en utilisant la fonction <code>facet_wrap()</code>. Vous pouvez facetter avec la fonction suivante : <code>facet_wrap(~ hair_color, nrow = 3)</code>.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/Faceting,%201%20variable-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Ensuite, vous pouvez essayer de facetter un graphique par deux variables catégoriques. Nous le ferons avec la fonction <code>facet_grid()</code>, en spécifiant les deux variables à l’intérieur de la fonction de la manière suivante : <code>facet_grid(gender ~ hair_color)</code>.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/faceting%20by%20two%20variables-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="exercise-7" class="level3">
<h3 class="anchored" data-anchor-id="exercise-7">Exercise 7</h3>
<p>Avant d’ajouter des lignes, nous devons calculer l’endroit où ces lignes doivent être placées. Ensuite, avec la fonction <code>geom_vline()</code>, nous ajouterons la ligne souhaitée.n with the function <code>geom_vline()</code> we will add the desired line.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Un problème courant lors de la facette est que, pour certaines observations, les axes ne sont pas les plus adaptés pour lire correctement le graphique. Pour cette raison, nous pouvons utiliser l’argument <code>scales = "free"</code> de la fonction <code>facet_grid()</code>.</p>
<p>Un autre problème possible que nous pouvons rencontrer lors de la facette est lorsque les étiquettes de facette (les catégories de la variable que nous utilisons pour facetter) sont si longues qu’elles sont coupées. Pour remédier à cela, nous pouvons utiliser l’argument <code>labeller</code> de la fonction <code>facet_grid()</code> de la manière suivante : <code>labeller = labeller(nom_variable = label_wrap_gen(width = 25))</code>.</p>
</section>
</section>
<section id="colour-of-the-background" class="level1">
<h1>Colour of the background</h1>
<section id="exercise-8" class="level3">
<h3 class="anchored" data-anchor-id="exercise-8">Exercise 8</h3>
<p>Sur le graphique de votre choix, changez la couleur de l’arrière-plan avec le code <code>panel.background = element_rect(fill = "lightblue", colour = "red", linewidth = 2)</code>.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/Colour%20of%20background-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
</section>
<section id="annotation" class="level1">
<h1>Annotation</h1>
<p><strong>Exemple d’annotation</strong></p>
<p>(copié et collé de (https://ggplot2.tidyverse.org/articles/faq-annotation.html))</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/anotated%20counts-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<p><img src="Ggplot2_files/figure-html/proportions-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>