---
title: "Introduction à la Visualisation de Données et à la Grammaire des Graphiques avec R"
author: " <br/>David Munoz Tord, Vestin Hategekimana & Iván Lorenci De Francisco"
date: " <br/>  `r format(Sys.Date(), '%Y-%b-%d')`"
output:
  xaringan::moon_reader:
    css: css/xaringan-themer.css
    nature:
      slideNumberFormat: "%current%"
      highlightStyle: github
      highlightLines: true
      ratio: 16:9
      countIncrementalSlides: true
      titleSlideClass: ["left", "centre", "my-title"]
---


```{r setup, echo=FALSE, fig.showtext = TRUE}
options(htmltools.dir.version = FALSE, warn = -1, message = -1, knitr.duplicate.label = 'allow')

knitr::opts_chunk$set(
  dpi=300,
  out.width = "100%",
  cache = TRUE,
  echo = FALSE,
  message = FALSE, 
  warning = FALSE,
  hiline = TRUE
)

xaringanthemer::style_mono_accent(
  base_color = "#1c5253",
  header_font_google = xaringanthemer::google_font("Josefin Sans"),
  text_font_google   = xaringanthemer::google_font("Montserrat", "300", "300i"),
  code_font_google   = xaringanthemer::google_font("Fira Mono")
)

custom_theme <- xaringanthemer::theme_xaringan(
  background_color = "#FFFFFF",
  text_font_size = 14
)

xaringanExtra::use_logo(
  position = xaringanExtra::css_position(top = "2.5em", right = "1.5em"),
  image_url = "https://wedata.ch/img/logo/wedata.png"
)

```


```{r packages-and-func, results='hide', message=FALSE, include=FALSE, warning=FALSE}
#this is to check to see if package are installed and if not to install them or just load them if they are installed!
if(!require(pacman)) {install.packages(c("pacman"))}

pacman::p_load(dplyr, dbplyr, tidyverse, hrbrthemes, xaringanthemer, kableExtra)

#The pacman package that can do this nicely. The function p_load in the package does this. The first line is just to ensure that pacman is installed.


#htmtools wrapper
image_link <- function(image,url,...){
  htmltools::a(
    href=url,
    htmltools::img(src=image,...)
    )
}
```


# Table des matières


.div.blue[
- Grammaire des Graphiques et Théorie
]

.div.blue[
- Implémentation: ggplot2
]


.div.blue[
- Aesthetic Mapping & Multidimensionalité
<!--Personnalisation Avancée et Thèmes -->
] 

.div.blue[
- Projets Pratiques
] 

<a href="https://we-data-ch.github.io/TakeOver_Dataviz_R/Presentation/DataViz_With_R.html">
`r icons::icon_style(icons::fontawesome("link"), fill = "#1c5253")` Link to follow this presentation !
</a>

<!--comments -->
???

Ce cours n'est pas une introduction à R, mais une introduction à la visualisation de données avec R. Il est donc nécessaire d'avoir une connaissance de base de R pour suivre ce cours. Si vous n'avez pas de connaissances de base en R, vous pouvez suivre le cours [Introduction à R](https://www.datacamp.com/courses/free-introduction-to-r) sur DataCamp.

De plus, ce cours ne pourra pas etre une exaustif quant a l'utilisation de ggplot2 car cela pourrait prendres des jours, mais il vous donnera les bases pour commencer à explorer et à créer vos propres graphiques.

---



# But

- Tentative d'inciter les gens à en savoir plus par eux-mêmes

- Partager mon point de vue personnel sur la raison pour laquelle la grammaire des graphiques domine pour la plupart des ensembles de données




```{r ,  fig.align="left"}
url <- "./img/graphs.png"
image_link(url,url,width="1000px")
```



---

class: inverse center middle

# Ressources

.pull-left[

```{r ,  fig.align="center"}
urlImage <- "https://r4ds.hadley.nz/cover.jpg"
url <- "https://r4ds.hadley.nz/data-visualize.html"
image_link(urlImage,url,width="300px")

```
]



.pull-right[
```{r ,  fig.align="center"}
urlImage <- "https://m.media-amazon.com/images/I/51smGgbUUjL._SL1251_.jpg"
url <- "http://www.ievbras.ru/ecostat/Kiril/R/Biblio_N/R_Eng/Wickham2016.pdf"
image_link(urlImage,url,width="270px")

```
]


<!--comments -->
???
- Hadley Wickham, le créateur de ggplot2, a écrit un livre sur la visualisation de données avec R, [R for Data Science](https://r4ds.had.co.nz/), qui est un excellent point de départ pour apprendre à utiliser ggplot2.




---

class: inverse center middle

# Grammaire des Graphiques

---

## Grammaire des Graphiques


- La grammaire des graphiques est un framework pour construire des graphiques en couches, en utilisant des composants de base pour construire des graphiques plus complexes



## Pourquoi?

- Framework agile pour l'exploration des données

- Permet de créer des graphiques complexes avec peu de code

- Géneralise facilement à de vaste ensemble de variables avec des hiérarchies complexes

---

class: inverse center middle

# Dataviz: Théorie

---


## Dataviz, un univers de possibilités

- On va **essayer** de faire un aperçu général de tous les **genre** de graphiques que l'on peut faire. 

  - **Distribution**: Histogramme, Densité, Boxplot, Violin, etc.
  - **Relation**: Scatterplot, Corrélogramme, heatmap, etc.
  - **Ranking**: Barplot, Spider chart, Parrallel, etc.
  - **Evolution**: Line Chart, Area Chart, etc.
  - **Partie d'un tout**: Treemap, Pie Chart, Doughnut, etc.
  - **Cartographie**: Choropleth, Bubble Map, etc.
  - **Réseau**: Network, Sankey, etc.


<!--comments-->

???
On peut faire 7 Meta categories de graphiques: Distribution, Relation, Ranking, Evolution, Partie d'un tout, Cartographie, Réseau.


---

#### Distribution: Visualiser la tendance d'une ou plusieurs variables numériques

.pull-left-small[

```{r ,  fig.align="center"}
url <- "./img/Distrib.png"
image_link(url,url,width="200px")

```
]

.pull-right-large[

- **Violin plot**: un hybride entre un boxplot en boîte et un density plot

<br>
- **Density plot**: les proportions de valeurs dans un intervalle continu

<br>
- **Histogram**: la fréquence des données en utilisant des intervalles de largeur égale (bins)

<br>
- **Boxplot**:  résume la distribution des données (médiane, quartiles, valeurs aberrantes)

]


<!--comments-->

???

- Les violons sont particulièrement adaptés lorsque la quantité de données est importante et qu'il est impossible de montrer des observations individuelles. on ajoute souvent un boxplot au milleu

- Les histogrammes et les diagrammes de densité sont tous deux utiles pour visualiser la distribution des données, mais ils montrent des choses légèrement différentes. Les histogrammes montrent les frequences, tandis que les diagrammes de densité montrent les proportions.

- Un boxplot montre la distribution des données quantitatives d'une manière qui facilite les comparaisons entre les variables ou entre les niveaux d'une variable catégorielle.

La ligne qui divise la boîte en deux parties représente la médiane. Les extrémités de la boîte indique les quartiles supérieur et inférieur. Les lignes extrêmes indiquent la valeur la plus élevée et la plus basse, apres cela on vois des  valeurs aberrantes. 
/ Attention! Le boxplot cache la taille de l'échantillon de chaque groupe, il faut l'afficher avec une annotation ou la largeur de la boîte. / !

Ordonner votre boxplot/violine par la médiane peut le rendre plus efficace


---

#### Relation: Relation entre 2 variables numériques/continues

.pull-left-small[

```{r ,  fig.align="center"}
url <- "./img/Corre.png"
image_link(url,url,width="200px")

```
]

.pull-right-large[


- **Scatter plot**: relation entre deux variables numériques

<br>

- **heatmap**: valeurs individuelles dans une matrice représentées par des couleurs

<br>
- **correlogram**:  une matrice, où chaque point représente la corrélation entre deux variables

<br>
- **bubble plot**:  un nuage de points avec une troisième variable numérique associée à la taille du cercle

]


<!--comments-->

???

La Overplotting est l'erreur la plus fréquente lorsque la taille de l'échantillon est élevée.

N'oubliez pas de montrer les sous-groupes si vous en avez.

carte thermique : Il faut souvent normaliser les données

Pensez aux échelles (log, sqrt, etc.) ! Et où elles commencent , a 0 ou autre chose ?

heatmap : C'est un peu comme regarder un tableau de données depuis le haut.

/ ! La palette de couleurs est importante / !

N'oubliez pas une légende pour la taille des bulles 

---

#### Pourquoi les graphiques en 3D sont une mauvaise idée


```{r ,  fig.align="right"}
url <- "./img/failureCircle.png"
image_link(url,url,width="800px")

```

<!--commemnts -->

???

n'utilisez jamais le graphique à bulles 3D parce qu'il s'échelonne quadratiquement !

La perspective est également la pire chose que l'on puisse faire à un graphique, car les objets les plus éloignés semblent plus petits, mais notre cerveau les perçoit comme étant plus grands qu'ils ne le sont.


---

#### Ranking: Comparer des valeurs numériques (unique ou moyenner) entre elles

.pull-left-small[

```{r ,  fig.align="center"}
url <- "./img/Ranking.png"
image_link(url,url,width="200px")

```
]

.pull-right-large[

- **Barplot**: chaque valeur de la variable catégorielle est représentée par une barre

<br>
- **Spider plot**: chaque variable a son propre axe, tous les axes sont reliés au centre de la figure

<br>
- **Wordcloud**: affiche une liste de mots, l'importance de chacun étant indiquée par la taille ou la couleur de la police

- **Parralel plot**: chaque observation est représentée par une ligne traversant une série d'axes parallèles, correspondant à une variable ou à une dimension spécifique 


]


<!--comments-->

???
Barplot vs histogramme
Barplot a ne pas confondre avec un histogramme. 

C-a-d -> la distance entre les barres n'a pas de sens, alors que la distance entre les barres dans un histogramme est importante.

Des noms tres longs ? Pensez à une version horizontale.
trier son barplot permet souvent de mieux comprendre la situation.


Les lollipop plot sont souvent plus attrayants que les diagrammes en barres, où la barre est transformée en une ligne et un point, ce qui est plus attrayant et transmet aussi bien l'information tout en étant moins encombré. je recommande.

Les wordcloud sont hype, mais ils déforment souvent la réalité et ne sont pas très effiace. Par exemple, les mots longs seront plus visibles etc..
Utiliser plutôt un lolipop plot horizontal trier ?

Le graphique parallèle permet de visualiser plusieurs dimensions à la fois. Il est souvent préférable au graphique en araignée, car les valeurs sont plus faciles à comparer lorsqu'elles sont disposées le long d'un seul axe vertical ou horizontal. 


---

#### Partie d'un tout: illustrer des proportions numériques

.pull-left-small[

```{r ,  fig.align="center"}
url <- "./img/Part.png"
image_link(url,url,width="200px")

```
]

.pull-right-large[

- **treemap**: chaque groupe est représenté par un rectangle dont la surface est proportionnelle à sa valeur

- **Venn diagramme**: chaque ensemble est représenté par un cercle, la taille du cercle représente l'importance du groupe, l'intersection des cercles indique les points communs entre les groupes

- **doughnut and pie chart**: un cercle divisé en secteurs qui représentent chacun une proportion de l'ensemble


]


<!--comments-->

???

Treemaps ont l'avantage d'utiliser efficacement l'espace, ce qui les rend utiles pour représenter une grande quantité de données. Mais n'annotez pas plus de 3 niveaux de la hiérarchie, cela rendrait la figure illisible.

Diagramme de Venn :  N'utilisez pas plus de 3 ensembles, cela rendrait la figure illisible.

Les pie chart sont très critiqués et doivent être évités autant que possible. L'être humain est très mauvais pour traduire des angles en valeurs.

Pourquoi ne pas plutôt envisager un stacked percentage bar plot ?

---

#### Evolution: Montrer des tendances temporelles pour ou plusieurs variables numeriqies

.pull-left-small[

```{r ,  fig.align="center"}
url <- "./img/Evo.png"
image_link(url,url,width="200px")

```
]

.pull-right-large[

- **line plot**: chaque observation est représentée par un point, les points sont reliés par des lignes

- **area plot**:  extension d'un line plot, la zone entre l'axe des x et la ligne est rempli par une couleur

<br>
- **stacked area et streamcharts**: extension d'un area plot, les zones sont empilées les unes sur les autres pour montrer l'évolution de plusieurs groupes


]


<!--comments-->

???

Lineplot : il est similaire à un scatter plot, à ceci près que les points de mesure sont ordonnés (généralement en fonction de leur valeur sur l'axe des x) et reliés par des segments de ligne droite. Un graphique linéaire est souvent utilisé pour visualiser une tendance dans les données sur des intervalles de temps - une série chronologique - et la ligne est donc souvent tracée chronologiquement.

Attention au graphique spaghetti : trop de lignes rendent le graphique illisible.

Je suis un grand fan des area chart et je pense qu'ils rendent la tendance plus évidente que l'utilisation d'un lineplot

Stacked area : il peut être difficile de lire l'évolution d'un groupe spécifique. L'ordre des groupes (de bas en haut) peut avoir une influenc.
Streamgraph (Graphique en flux) : il n'y a pas de coin : les bords sont arrondis, ce qui donne une belle impression de flux. 

Bon pour étudier les proportions relatives de l'ensemble.

---


#### Cartographie: Visualiser des données géographiques

.pull-left-small[

```{r ,  fig.align="center"}
url <- "./img/Cart.png"
image_link(url,url,width="200px")

```
]

.pull-right-large[

- **carte**: projection de coordonnées géographiques sur une carte

<br>
- **chloropleth**:  chaque région est colorée en fonction de la valeur d'une variable

<br>
- **hexbin map**: chaque région est remplie de petits hexagones, la couleur de l'hexagone indique la valeur d'une variable

<br>
- **cartogram**: chaque région est redimensionnée en fonction de la valeur d'une variable

]


<!--comments-->

???

Les cartes sont un excellent moyen de visualiser des données géographiques.

carte choroplèthe : Normalisez votre variable : vous ne pouvez pas comparer des chiffres bruts entre des régions de taille ou de population différentes.

Si vos régions ont des tailles très diverses, cela introduit un biais.
Ne l'appelez pas carte choroplèthe, mais carte chOrOpleth.

La carte hexagonale est une sorte de carte choroplèthe. Elle supprime le biais introduit par la taille différente des régions dans la carte choroplèthe, puisque chaque région est représentée par le même hexagone.

Le cartogramme vise à corriger le biais : lorsqu'une variable est agrégée par région, une région avec très peu de points de données semblera aussi importante qu'une région avec beaucoup de points de données.


---


#### Réseaux: Visualiser des relations entre des entités (noeuds et liens)

.pull-left-small[

```{r ,  fig.align="center"}
url <- "./img/Network.png"
image_link(url,url,width="200px")

```
]

.pull-right-large[

- **chord diagram**: chaque entité est représentée par un arc, la taille de l'arc est proportionnelle à la valeur d'une variable


- **graph diagram**: la taille des noeuds et des arcs est proportionnelle à la valeur d'une variable

<br>
- **Sankey  diagram**: plusieurs entités (nœuds) sont représentées par des rectangles, la relation entre ces entités est représentée par des liens proportionnels à une valeur

- **arc diagram**: nœuds sont affichés le long d'un axe unique et les liens sont représentés par des arcs

]


<!--comments-->

???

Les réseaux constituent un domaine de recherche à part entière. Les diagrammes de réseaux ne sont pas faciles à comprendre. Donnez beaucoup d'explications à votre public lorsque vous les présentez.
Attention à l'encombrement et à l'absence de connexions faibles ?

Chord: L'ordre des groupes autour du cercle est important, il est préférable de minimiser le nombre d'arcs qui se croisent.

Il existe plusieurs types de graphs dirgams Ils peuvent être dirigés (flux) ou non dirigés (connexion). Les liens peuvent être mis en évidence ou non.

Sankey diagrams permet de visualiser les flux. 


Arc : permet de mettre en évidence les clusters en 2D

---

class: inverse center middle

# Quiz #1

---

## Quiz #1


- Quel type de graphique est le plus adapté pour visualiser la relation entre deux variables continues (e.g. taille et poids) ?
--
 **Scatter plot**
--

- Quel type de graphique est le plus adapté pour comparer visuellement la distribution de deux variables continues avec beaucoup de points (e.g. age d'une population par sexe) ?
--
 **Violon plot / boxplot**
--

- Quel type de graphique est le plus adapté pour visualiser la corrélation entre **toutes** les variables d'un dataset ?
--
 **Correlogram **
--

- Quel type de graphique est le plus adapté pour visualiser l'évolution de la température moyenne en France au cours des 50 dernières années ?
--
 **Line plot ou area plot**
--

- Quel type de graphique est le plus adapté pour visualiser la répartition des ventes de voitures par marque ?
--
 **Bar plot**
--
 / Et par marque et par année ?
--
 **(Stacked) bar plot empilé**
--

- Quel type de graphique est le plus adapté pour visualiser les relations entre les pays de l'UE ?
--
 **Graph diagram**

 
---














class: inverse center middle

# Implémentation: GGplot2 

---

## GGplot2 

.pull-left-large[

- GGplot2 est une implémentation de la grammaire des graphiques en R, crée par Hadley Wickham. 

<br>
- Vous fournissez les données, dites à ggplot2 comment faire correspondre les variables à l'esthétique, quelles graphiques utiliser, et il s'occupe des détails.

<br>
- Disponible sur R [ggplot2](https://ggplot2.tidyverse.org/) et Python [plotnine](https://plotnine.readthedocs.io/en/v0.12.3/)



]




.pull-right-small[
```{r ,  fig.align="right"}

url <- "https://camo.githubusercontent.com/a6cc89d06ac569b886318ed743f16cdbcf0f2fe7bce5804bdcd1c160b99797f2/687474703a2f2f692e696d6775722e636f6d2f4472496c522e706e67"
image_link(url,url,width="270px")

```
]

<!--comments-->

???

Imaginer React /Vue vs Vanilla JS
les gens peuvent trouver ca "trop compliquer" mais c'est plus facile a utiliser et plus puissant


---

## Syntaxe de GGplot2


.pull-left-large[

- **Data**: Les données à utiliser pour créer le graphique
- **Aesthetic**: Les caractéristiques visuelles du graphique
- **Geom**: La géométrie qui représente les données
- **Scale**: Comment les caractéristiques visuelles sont converties en valeurs d'affichage
- **Statistics**: Transformations statistiques. Comptes, Moyennes, etc.
- **Coordinates**: Système numérique pour déterminer la position de la géométrie. Cartésien, Polaire, etc.
- **Facets**: Diviser les données en sous-ensembles
- **Theme**: Personnalisation des éléments non liés aux données

]

.pull-right-small[
```{r ,  fig.align="right"}
url <- "https://nbisweden.github.io/RaukR-2019/ggplot/presentation/ggplot_presentation_assets/gog.png"
image_link(url,url,width="240px")


url <- 'https://nbisweden.github.io/RaukR-2019/ggplot/presentation/ggplot_presentation_assets/syntax.png'

image_link(url,url,width="370px")
```
]


---

class: inverse center middle

# Familiarisation

---


## Données sur le taux de suicide (1985- 2016)

```{r, echo=FALSE}

##suicide rate data
df <- read.csv("data/suicides.csv") 


kable(df[1:100, ],format="html",escape = F, col.names = colnames(df)) %>% 
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "400px")
```


<!--comments-->

???


---
## Basic R VS GGplot2

.pull-left[
```{r , eval=FALSE, echo=TRUE}

plot(df$population, df$suicides_no) # Basic R
```

```{r ,  fig.align="left", out.width="400px", out.height="400px"}

# Basic R 
plot(df$population, df$suicides_no)

```

]

.pull-right[
```{r , eval=FALSE, echo=TRUE}
ggplot(data=df, mapping=aes(x=population, y=suicides_no)) + 
  geom_point() # ggplot2
```


```{r ,  fig.align="left", out.width="340px", out.height="340px"}

# ggplot2
ggplot(df, aes(x=population, y=suicides_no)) +
  geom_point() +
  theme_xaringan(background_color = "#FFFFFF")

```

]

<!--comments -->
???
ils sont tous les deux des graphiques de dispersion, 
mais deja ggplot2 me parait plus facile a lire et a comprendre

En quelque mots, le premier parametre est le dataframes, le deuxieme est aes qui est un objet qui contient les variables que l'on veut utiliser pour le graphique, ici x pour l'axe des abscisses et y pour l'axe des ordonnées,

et le troisieme est la geometrie du graphique, ici un point

---


## Comment colorer les points par sexe?

- Traditionnellement, on utilisait le fromat **wide** des données pour les graphiques groupés

```{r , eval=T, echo=F}
df_wide <- df %>% 
  pivot_wider(values_from = c("population", "suicides_no"),
              names_from = "sex",
              id_cols = c("country", "year", "age"))

kable(df_wide[1:100, ],format="html",
      escape = F, col.names = colnames(df_wide)) %>% 
  kable_styling(font_size=16) %>%
  kableExtra::scroll_box(width = "100%", height = "400px")

```

<!--comments  -->

???

---
## Old school way

.pull-left-large[
```{r , eval=FALSE, echo=TRUE}
# Basic R

# D'abord une premiere couche avec les femmes
plot(df_wide$population_female, 
     df_wide$suicides_no_female, col="blue") 

# après on ajoute les hommes
points(df_wide$population_male, 
       df_wide$suicides_no_male, col="red") 
```
]

.pull-right-small[

```{r ,  fig.align="left", out.width="400px", out.height="400px"}

# Basic R 
plot(df_wide$population_male, df_wide$suicides_no_male, col="blue") #Basic R
points(df_wide$population_female, df_wide$suicides_no_female, col="red") 

```

]

<!--comments  -->
???
Stupide et compliqué

---

## GGplot2 way

- **ggplot2** utilise le format 'long' pour les graphiques groupés (reminder)

- une columne = une variable !

```{r, echo=FALSE}

kable(df[1:100, ],format="html",escape = F, col.names = colnames(df)) %>% 
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "300px")
```


---

## Comment colorer les points par sexe?

.pull-left[
```{r , eval=FALSE, echo=TRUE}
ggplot(df, aes(x=population, 
               y=suicides_no, 
               color=sex)) +
geom_point()
```
]


.pull-right[

```{r ,  fig.align="left", out.width="500px", out.height="400px"}

ggplot(df, aes(x=population, y=suicides_no, color=sex)) +
  geom_point() +
  custom_theme

```

]

<!--comments  -->
???
Deja la syntaxe est plus simple, on a pas besoin de specifier les variables a chaque fois, on peut les specifier une fois pour toute dans aes.

On rajoute juste un nouveau mapping, ici "color" et bam tout le reste est fait pour nous

---

class: inverse center middle

# Aesthetics 

Les rouages de ggplot2

---

## Aesthetics

  -   **x** pour l'axe des abscisses
  -   **y** pour l'axe des ordonnées
  -   **color** pour la couleur (les bords)
  -   **size** pour la taille
  -   **shape** pour la forme
  -   **alpha** pour la transparence
  -   **linetype** pour le type de ligne
  -   **fill** pour le remplissage
  -   et plein d'autres encore...
    
<!--comments-->

???
- **aes** est un objet qui contient les variables que l'on veut utiliser pour le graphique

---


## Colorer par pays? Easy

.pull-left[
```{r , eval=FALSE, echo=TRUE}
ggplot(df, aes(x=population, 
               y=suicides_no, 
               color=country)) +
geom_point()
```
]


.pull-right[

```{r ,  fig.align="left", out.width="500px", out.height="400px"}

ggplot(df, aes(x=population, y=suicides_no, color=country)) +
  geom_point() +
  custom_theme

```

]

<!--comments  -->
???
Super easy on rmeplace juste le color aestic par la variable country

La maniere traditionnelle de faire des graphiques groupés aurait demandé de recodé le tout

---

## Forme par pays? Pfff..

.pull-left[
```{r , eval=FALSE, echo=TRUE}
ggplot(df, aes(x=population, 
               y=suicides_no, 
               shape=country)) +
geom_point()
```
]


.pull-right[

```{r ,  fig.align="left", out.width="500px", out.height="400px"}

ggplot(df, aes(x=population, y=suicides_no, shape=country)) +
  geom_point() +
  custom_theme

```

]

<!--comments  -->
???
Pff.. juste chnager color par shape !

---

class: inverse center middle

# Geoms 

Le plus utile

---

## Geoms 

- Les **geoms** sont les élements géometrics qui vont **reprensenter** les données
    -   ** geom_point()** pour les nuage de points
    -  **geom_line()** pour les lignes
    -   **geom_bar()** pour les barres
    -   **geom_boxplot()** pour les boites à moustaches
    -   **geom_histogram()** pour les histogrammes
    -   **geom_density()** pour les densités
    -   **geom_smooth()** pour les courbes de tendances
    -  **geom_area()** pour les aires
    - **geom_violin()** pour les violons
    -   et plein d'autres encore...
  
  
```{r ,  echo=TRUE, eval=FALSE}
help.search("^geom_",package="ggplot2") 
```


<!--comments-->

???
geom stands for geometric object 

il y a des dizaines de geoms dans ggplot2, on va en voir quelques unes aujourd'hui



---

## Exemples

```{r ,  fig.align="left", out.width="500px", out.height="400px"}
url <- 'https://nbisweden.github.io/RaukR-2019/ggplot/presentation/ggplot_presentation_assets/geoms.png'

image_link(url,url,width="1070px")
```


<!-- comments -->

On en a deja vu quelques unes, mais il y a en des centaines d'autres

point histogram et density sont les plus courants

---

## Regression par pays

.pull-left[
```{r , eval=FALSE, echo=TRUE}
ggplot(df, aes(x=population, 
               y=suicides_no, 
               color=country)) +
geom_point() + 
geom_smooth() 
# on rajoute une courbe de tendance
```
]


.pull-right[

```{r ,  fig.align="left", out.width="500px", out.height="400px"}

ggplot(df, aes(x=population, 
               y=suicides_no, 
               color=country)) +
geom_point(alpha=0.3) + 
geom_smooth(method="lm", formula=y~x) +
  custom_theme

```

]

<!--comments  -->
???

on rajoute une courbe de tendance


---


## Regression pour l'ensemble des pays



.pull-left[
```{r , eval=FALSE, echo=TRUE}
ggplot(df, aes(x=population, 
               y=suicides_no)) +
geom_point(aes(color=country)) + 
geom_smooth() 
# on rajoute une courbe de tendance
```

- On peut séparer les geoms individuelement !


]


.pull-right[

```{r ,  fig.align="left", out.width="500px", out.height="400px"}

ggplot(df, aes(x=population, 
               y=suicides_no)) +
geom_point(aes(color=country), alpha=0.3) + 
geom_smooth(method="lm", formula=y~x) +
  custom_theme

```

]

<!--comments  -->
???
En enlevent le color de aes, on peut le mettre dans geom_point et ca va colorer/grouper les points par les payes mais pas la courbe de tendance. 

Elle reste globale.

Attention l'ordre compte.

---

## Analogie anatomique


.pull-left[
```{r , eval=FALSE, echo=TRUE}
ggplot(df, aes(x=population, 
               y=suicides_no, label = age)) +
geom_point(aes(color=country)) 






ggplot(df, aes(x=population, 
               y=suicides_no, label = age)) +
geom_text(aes(color=country)) 
```


]


.pull-right[

```{r ,  fig.align="left", out.width="500px", out.height="400px"}

x <- ggplot(df, aes(x=population, 
               y=suicides_no, label = age)) +
geom_point(aes(color=country)) +
  custom_theme



y <- ggplot(df, aes(x=population, 
               y=suicides_no, label = age)) +
geom_text(aes(color=country)) +
  custom_theme

gridExtra::grid.arrange(x,y,nrow=2)
```

]

<!--comments  -->
???


L'analogie est celle des genes et de l'environnement. L'aes est les genes, les geoms sont l'environnement.

Dependant de l'environnement, les genes vont s'exprimer differement.

Certain aes ne vont rien faire avec certain geoms. Par exemple, shape ne va rien faire avec geom_smooth et label ne va rien faire avec geom_point alors quil change tout avec geom_text!

---

class: inverse center middle

# Stats

Le coeur du data sciencist

---

## Statistiques

- On peut rajouter des statistiques sur les graphiques
    -   **smooth()** pour les courbes de tendances
    -   **summary()** pour les résumés statistiques
    -   **density()** pour les densités
    -   **ellipse()** pour les ellipses de confiance
    -   **qq()** pour les graphiques quantiles-quantiles
    -   et plein d'autres encore...
    
---

## Exemples


.pull-left[

- Les statistiques calculent de nouvelles variables à partir des données d'entrée. Les geoms ont des statistiques par défaut mais on peut les changer.



```{r , eval=FALSE, echo=TRUE}

ggplot(iris) + geom_bar(aes(x=Sepal.Length),
                        stat="bin")

ggplot(iris) + geom_bar(aes(x=Species),
                        stat="count")

ggplot(iris) + geom_bar(aes(x=Species,
                            y=Sepal.Length),
                        stat="identity")


```

]

.pull-right[

```{r ,  fig.align="left", out.width="500px", out.height="400px"}

x <- ggplot(iris) + geom_bar(aes(x=Sepal.Length),stat="bin")
y <- ggplot(iris) + geom_bar(aes(x=Species),stat="count")
z <- ggplot(iris) + geom_bar(aes(x=Species,y=Sepal.Length),stat="identity")
gridExtra::grid.arrange(x,y,z,nrow=1)

```

]

---

## Regression par pays (mais pour de vrai)

.pull-left[
```{r , eval=FALSE, echo=TRUE}
ggplot(df, aes(x=population, 
               y=suicides_no, 
               color=country)) +
geom_point() + 
geom_smooth(method="lm", formula=y~x)
# on rajoute une method a une formule


ggplot(df, aes(x=population, 
               y=suicides_no, 
               color=country)) +
geom_point() + 
geom_smooth()
# sinon par default geom_smooth() utilise
# method = 'loess' and formula = 'y ~ x'

```
]


.pull-right[

```{r ,  fig.align="left", out.width="500px", out.height="450px"}

x <- ggplot(df, aes(x=population, 
               y=suicides_no, 
               color=country)) +
      geom_point(alpha=0.3) + 
      geom_smooth(method="lm", formula=y~x) +
        custom_theme


y <- ggplot(df, aes(x=population, 
               y=suicides_no, 
               color=country)) +
      geom_point(alpha=0.3) + 
      geom_smooth() +
        custom_theme

gridExtra::grid.arrange(x,y,nrow=2)

```

]

<!--comments  -->
???

je vous ai "menti" un peu. La regression il y avait des arguments caché dans ma commande


---

class: inverse center middle

# Scales

To cut or no to cut

---

## Graphiques malhonnêtes


```{r, fig.align='center'}

url <- "https://static1.squarespace.com/static/55b6a6dce4b089e11621d3ed/55b6d08fe4b0d8b921b02f83/55b6d0a3e4b0d8b921b03574/1438044323461/1000w/"

image_link(url,url,width=600)

```

<!-- comments-->

???


Couper ou ne pas couper l'axe des Y est probablement l'un des sujets les plus controversés en matière de visualisation de données. Il y a clairement des acteurs malhonnetes qui vont couper l'axe des Y pour faire croire que les données sont plus importantes qu'elles ne le sont en réalité. Mais il y a aussi des cas où couper l'axe des Y est une bonne idée.

Quand est-ce que c'est une bonne idée de couper l'axe des Y? Bah en general avec les times series on veut montrer les tendances et pas les valeurs absolues. Donc on peut couper l'axe des Y pour montrer les tendances VS un baseline; Mais il faut le faire avec parcimonie et en indiquant clairement que l'axe est coupé.


barplot : Pour ce type de graphique, il existe un consensus : l'axe des ordonnées doit commencer à 0.
Lineplot: il n'y a pas de consensus, même si, en général, il n'est pas nécessaire de commencer à 0.


---

## Changer les échelles

.pull-left[

- On peut changer les échelles des axes
    -   **scale_x_log10()** pour une échelle logarithmique
    -   **scale_x_reverse()** pour inverser l'axe
    -   **scale_x_sqrt()** pour une échelle racine carrée


```{r , eval=FALSE, echo=TRUE}
ggplot(df, aes(x=population, 
               y=suicides_no)) +
geom_point(aes( color=country)) +
scale_x_log10() +
scale_y_log10() 
```
]

.pull-right[
```{r ,  fig.align="left", out.width="500px", out.height="400px"}

ggplot(df, aes(x=population, 
               y=suicides_no)) +
geom_point(aes( color=country), alpha=0.3) +
scale_x_log10() +
scale_y_log10() +
custom_theme

```

]

<!--comments -->
???
C'est hyper simple de changer les échelles des axes. Il suffit d'utiliser les fonctions scale_x_log10() et scale_y_log10() pour une échelle logarithmique, scale_x_reverse() pour inverser l'axe, scale_x_sqrt() pour une échelle racine carrée, etc.

---

class: inverse center middle

# Position

Comment positionner les geoms

---

## Position

.pull-left[

- On peut changer la position des geoms
    -   **dodge()** pour les barres côte à côte
    -   **jitter()** pour les points avec un peu de bruit
    -   **stack()** pour les barres empilées
    -   **position_identity()** pour les points
    -   et plein d'autres encore...

```{r , eval=FALSE, echo=TRUE}

ggplot(df,aes(x=age,y=suicides_no,fill=country))
 + geom_bar(stat="identity",position="stack")


ggplot(df,aes(x=age,y=suicides_no,fill=country))
 + geom_bar(stat="identity",position="dodge") 

```

]

.pull-right[
```{r ,  fig.align="left", out.width="500px", out.height="450px"}
df$age <- gsub(" years", "", df$age)
df$age <- factor(df$age, levels = c("5-14", "15-24", "25-34", "35-54", "55-74", "75+"))

p <- ggplot(df,aes(x=age,y=suicides_no,fill=country)) + custom_theme

x <- p + geom_bar(stat="identity",position="stack")
y <- p + geom_bar(stat="identity",position="dodge") 

gridExtra::grid.arrange(x,y, nrow=2)

```

]


---

## Jitter

.pull-left[


```{r , eval=FALSE, echo=TRUE}

#sans jitter / sans alpha
ggplot(df, aes(x=age, y=suicides_no, color=country)) +
  geom_point()





#avec jitter / avec alpha
ggplot(df, aes(x=age, y=suicides_no, color=country)) +
  geom_point(position="jitter", alpha=0.3) 

```

]


.pull-right[
```{r ,  fig.align="left", out.width="500px", out.height="450px"}

#sans jitter / sans alpha
x <- ggplot(df, aes(x=age, y=suicides_no, color=country)) +
  geom_point() +
  custom_theme


#avec jitter / avec alpha
y <- ggplot(df, aes(x=age, y=suicides_no, color=country)) +
  geom_point(position="jitter", alpha=0.3) +
  custom_theme

gridExtra::grid.arrange(x,y, nrow=2)

```

]

<!--comments -->
???
Premier est illisible est le second a deja pas mal plus de lisibilité


---

## Jitter + Boxplot / Violin

.pull-left[


```{r , eval=FALSE, echo=TRUE}

#jitter  + boxplot
ggplot(df, aes(x=age, y=suicides_no)) +
  geom_boxplot() +
  geom_point(position="jitter", alpha=0.3)

```

]


.pull-right[
```{r ,  fig.align="left", out.width="500px", out.height="450px"}

ggplot(df, aes(x=age, y=suicides_no)) +
  stat_boxplot(geom ='errorbar') + 
  geom_boxplot(outlier.shape = NA) +
  geom_point(position="jitter", alpha=0.3) + 
  custom_theme

```

]

<!--comments -->
???

Un des types de plots que j'utilise le plus pour explorer les données, très puissant et très simple à faire

---

class: inverse center middle

# Facets

---


## Facettes (Unidimensionnelles)


.pull-left[


```{r , eval=FALSE, echo=TRUE}


#meme echelle partout
ggplot(df, aes(x=age, y=suicides_no)) +
  geom_boxplot() +
  geom_point(position="jitter", alpha=0.3) +
  facet_wrap(~country)

#echelle libre
ggplot(df, aes(x=age, y=suicides_no)) +
  geom_boxplot() +
  geom_point(position="jitter", alpha=0.3) +
  facet_wrap(~country, scales = "free")

```

]

.pull-right[


```{r ,  fig.align="left", out.width="500px", out.height="450px"}

x <- ggplot(df, aes(x=age, y=suicides_no)) +
      geom_boxplot() +
      geom_point(position="jitter", alpha=0.3) +
      facet_wrap(~country) +
      custom_theme + 
       theme(axis.text.x = element_text(size = 9, angle = 90))

y <- ggplot(df, aes(x=age, y=suicides_no)) +
      geom_boxplot() +
      geom_point(position="jitter", alpha=0.3) +
      facet_wrap(~country, scales = "free") +
      custom_theme + 
       theme(axis.text.x = element_text(size = 9, angle = 90))


gridExtra::grid.arrange(x,y,nrow=2)

```

]


<!-- comments -->
???

- On peut faire des facettes
    -   **facet_wrap()** pour des facettes en une dimension
    

---


## Facettes (Multidimensionnelles: 2D)

.pull-left[

```{r , eval=FALSE, echo=TRUE}

ggplot(df, aes(x=age, y=suicides_no)) +
  geom_boxplot() +
  geom_point(position="jitter", alpha=0.3) +
  facet_grid(country~sex, scales = "free")

```

]

.pull-right[

```{r ,  fig.align="left", out.width="500px", out.height="450px"}

ggplot(df, aes(x=age, y=suicides_no)) +
  geom_boxplot() +
  geom_point(position="jitter", alpha=0.3) +
  facet_grid(country~sex, scales = "free") +
  custom_theme + 
  theme(axis.text.x = element_text(size = 9, angle = 90))

```

]


<!-- comments -->
???

- ou en deux dimensions
    -   **facet_grid()** 
la c'est juste un exemple, la j'ai mis les echelles en libre pour que ca soit plus lisible mais c'est pas forcement une bonne idée


---

class: inverse center middle

# Tout ensemble


---


## Mettons tout ensemble


On va essayer de poser la question: 

Comment peut-on visualiser une **comparaison par sexe** des tendances du **nombre de suicide** à travers **les années** dans **chaque pays** et dans chaque **groupe d'age**?

<br> 
<br> 
--
ggplot(**df**, aes(x=
--
 **year**, 
--
 y=
--
 **suicides_no**,
--
 color=
--
 **sex**)) +
--
<br>   geom_line() +
--
<br>   geom_smooth(method = 
--
 **"lm"**, se = FALSE)
--
 <br>   facet_grid(
--
 **country~age**, scales = "free") +




<!-- comment: -->
???

On peut ainsi voir une ligne de regression pour chaque groupe. Ce qui nous permet de voir clairement ce qui se passe avec le nombre de suicide a travers le temps dans chaque pays et dans chaque groupe d'age, et par sex.

Voila en 4 ligne, on peut obtenir une visualisation assez complexe et qui tient la route. Cela nous aurait pris beeeeaucoup plus de temps avec un approche tradtionnelle. et le pire c'est que si on finiissait avec cela avec une approche tradtionnelle cela serait encore hyper chiant de changer si on aime pas le resultat

J'espere que cet exemple vous montre l'interet des facettes, on peut faire des graphiques tres riches en information et tres lisibles. et cela montre aussi l´agilité du framework ggplot2


---


```{r ,  fig.align="center", out.width="650px"}

ggplot(df, aes(x=year, y=suicides_no,color=sex)) +
  geom_line() +
  geom_smooth(formula= 'y~x', method = "lm", se = FALSE) + 
  facet_grid(country~age, scales = "free") +
  custom_theme + 
  theme(axis.text.x = element_text(size = 9, angle = 90))


```

---

class: inverse center middle

# Travail Pratique 1: Base + graph design

---

class: inverse center middle

# Travail Pratique 2: Documentation et reproduction de graphs

---

class: inverse center middle

# Interactivité

le fun!

---

## Facile avec Plotly !


.pull-left[

```{r , eval=FALSE, echo=TRUE}
#creer le graphique
p <- ggplot(df, aes(x=population, y=suicides_no)) +
      geom_point(aes(color=country)) +
      geom_smooth() +
      custom_theme 

#envelopper dans ggplotly
plotly::ggplotly(p)
``` 

]


.pull-right[

```{r ,  fig.align="left", out.width="500px", out.height="450px"}

p <- ggplot(df, aes(x=population, y=suicides_no)) +
      geom_point(aes(color=country)) +
      geom_smooth() +
      custom_theme 


plotly::ggplotly(p)
``` 

]


<!-- comments -->
???

- ggplotly() permet de transformer un graphique ggplot2 en graphique plotly

---

class: inverse center middle

# Conclusions

En bref

---

## Avantages de ggplot2

<br><br>
- Exploration agile des données : itération rapide

- L'aesthétique permet de superposer des hiérarchies de caractéristiques

- Les géoms gèrent une grande partie des éléments complexes, ce qui réduit les risques d'erreur

- Domine l'approche traditionnelle pour les ensembles de données riches


<!-- comments -->
???

ne nécessite que très peu de changements

---


## Cheat sheet



```{r ,  fig.align="right"}
urlImage <- "./img/cheat.png"
url <- "https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-visualization-2.1.pdf"
image_link(urlImage,url,width="650px")

```



---

## Web R Console


 <iframe src="https://munoztd0.shinyapps.io/Tuto_learnR_Data_Viz/" width="100%" height="500px" id="iframe1" marginheight="0" frameborder="0" onload='javascript:resizeIframe(this);'></iframe>
 
 
 
 
---
class: inverse center middle


# Thanks!


<a href="mailto:david.munoz@mailbox.org">
.white[`r icons::icon_style(icons::fontawesome("paper-plane"), fill = "white")` david.munoz@mailbox.org]
</a>

<a href="https://github.com/we-data-ch/TakeOver_Dataviz_R">
.white[`r icons::icon_style(icons::fontawesome("link"), fill = "white")` This presentation repository]
</a>

<a href="http://twitter.com/tord_munoz">
.white[`r icons::icon_style(icons::fontawesome("twitter"), fill = "white")` @tord_munoz]
</a>

<a href="https://github.com/munoztd0">
.white[`r icons::icon_style(icons::fontawesome("github"), fill = "white")` @munoztd0]
</a>

<a href="https://www.youtube.com/channel/UCGktdbvbc_H-JEkYYTvwRVw">
.white[`r icons::icon_style(icons::fontawesome("youtube"), fill = "white")` We Data YouTube]
</a>

<br>

Slides created via the R packages:

*xaringan* and *xaringanthemer*


